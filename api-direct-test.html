<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sermon Embeddings Dashboard</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
    }
    pre {
      background-color: #f5f5f5;
      padding: 10px;
      border-radius: 5px;
      overflow-x: auto;
    }
    button {
      background-color: #2ea3f2;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      margin-right: 8px;
      margin-bottom: 8px;
    }
    input, textarea, select {
      width: 100%;
      padding: 8px;
      margin-bottom: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-sizing: border-box;
    }
    .success { color: green; }
    .error { color: red; }
    .warning { color: orange; }
    .section {
      margin-bottom: 30px;
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 5px;
    }
    .card {
      border: 1px solid #ddd;
      border-radius: 5px;
      padding: 10px;
      margin-bottom: 10px;
    }
    .stats {
      display: flex;
      flex-wrap: wrap;
      margin-bottom: 15px;
    }
    .stat-card {
      background-color: #f9f9f9;
      border: 1px solid #ddd;
      border-radius: 5px;
      padding: 15px;
      margin-right: 15px;
      margin-bottom: 15px;
      min-width: 150px;
      text-align: center;
    }
    .stat-value {
      font-size: 24px;
      font-weight: bold;
      margin: 10px 0;
    }
    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(0, 0, 0, 0.1);
      border-radius: 50%;
      border-top-color: #2ea3f2;
      animation: spin 1s ease-in-out infinite;
      margin-left: 10px;
      vertical-align: middle;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    .latest-sermon {
      background-color: #e6f7ff;
      border-left: 5px solid #2ea3f2;
    }
    .highlight {
      background-color: #ffffcc;
    }
    .tabs {
      display: flex;
      margin-bottom: 15px;
    }
    .tab {
      padding: 10px 15px;
      cursor: pointer;
      border: 1px solid #ddd;
      background-color: #f5f5f5;
      border-bottom: none;
      border-radius: 5px 5px 0 0;
      margin-right: 5px;
    }
    .tab.active {
      background-color: white;
      border-bottom: 2px solid white;
    }
    .tab-content {
      display: none;
      border: 1px solid #ddd;
      padding: 15px;
      border-radius: 0 5px 5px 5px;
    }
    .tab-content.active {
      display: block;
    }
    .video-preview {
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <h1>Sermon Embeddings Dashboard</h1>
  <p>This dashboard helps you monitor your sermon data in Pinecone, showing latest videos with embeddings status.</p>
  
  <div class="section">
    <h2>API Configuration</h2>
    <div>
      <label for="apiUrl">API URL:</label>
      <input type="text" id="apiUrl" value="https://sermon-search-api-8fok.onrender.com">
    </div>
    <button id="updateApiUrl">Update API URL</button>
    <button id="refreshAllData">Refresh All Data</button>
  </div>
  
  <!-- NEW SECTION: Latest Sermon Status -->
  <div class="section">
    <h2>Latest Sermon Status</h2>
    <p>Shows the most recent sermons in your system and their embedding status</p>
    <div class="stats">
      <div class="stat-card">
        <div>Latest Sermon Date</div>
        <div class="stat-value" id="latestSermonDate">-</div>
        <div>Most recent sermon date</div>
      </div>
      <div class="stat-card">
        <div>Days Since Latest</div>
        <div class="stat-value" id="daysSinceLatest">-</div>
        <div>Days since most recent sermon</div>
      </div>
      <div class="stat-card">
        <div>Latest Embedding</div>
        <div class="stat-value" id="latestEmbeddingDate">-</div>
        <div>Most recent sermon with embeddings</div>
      </div>
    </div>
    
    <div id="latestSermonCard" class="card latest-sermon">
      <h3 id="latestSermonTitle">Loading latest sermon...</h3>
      <p><strong>ID:</strong> <span id="latestSermonId">-</span></p>
      <p><strong>Date:</strong> <span id="latestSermonFullDate">-</span></p>
      <p><strong>Status:</strong> <span id="latestSermonStatus">-</span></p>
      <p><strong>YouTube:</strong> <a id="latestSermonLink" href="#" target="_blank">View on YouTube</a></p>
      <div class="video-preview" id="latestSermonPreview"></div>
    </div>
    
    <button id="checkLatestBtn">Check Latest Sermon Status</button>
  </div>
  
  <div class="section">
    <h2>Database Statistics</h2>
    <p>View basic statistics about your Pinecone vector database.</p>
    <div class="stats">
      <div class="stat-card">
        <div>Total Vectors</div>
        <div class="stat-value" id="totalVectors">-</div>
        <div>Total sermon chunks in Pinecone</div>
      </div>
      <div class="stat-card">
        <div>Total Sermons</div>
        <div class="stat-value" id="totalSermons">-</div>
        <div>Unique sermon videos</div>
      </div>
      <div class="stat-card">
        <div>Avg. Chunks Per Sermon</div>
        <div class="stat-value" id="avgChunks">-</div>
        <div>Average vector chunks per sermon</div>
      </div>
    </div>
    <button id="fetchStatsBtn">Fetch Database Stats</button>
    <div id="statsResult"></div>
  </div>
  
  <div class="section">
    <h2>Sermons List</h2>
    <p>View all sermons in the database with their vector counts.</p>
    <div>
      <label for="sortBy">Sort by:</label>
      <select id="sortBy">
        <option value="date">Date (newest first)</option>
        <option value="chunks">Vector Chunks (most first)</option>
        <option value="title">Title (A-Z)</option>
      </select>
    </div>
    <button id="fetchSermonsBtn">Fetch Sermons List</button>
    <input type="text" id="filterSermons" placeholder="Filter sermons by title or ID...">
    <div id="sermonsResult">
      <div id="sermonsList"></div>
    </div>
  </div>
  
  <div class="section">
    <h2>Semantic Search Test</h2>
    <p>Test a semantic search query to verify Pinecone retrieval.</p>
    <div>
      <label for="searchQuery">Search Query:</label>
      <textarea id="searchQuery" rows="3">What does the pastor teach about faith?</textarea>
    </div>
    <div>
      <label for="topK">Number of Results:</label>
      <input type="number" id="topK" value="5" min="1" max="20">
    </div>
    <button id="testSearchBtn">Run Semantic Search</button>
    <div id="searchResult"></div>
  </div>
  
  <div class="section">
    <h2>Vector Metadata Explorer</h2>
    <p>Explore the metadata for vector chunks from a specific sermon.</p>
    <div>
      <label for="videoId">Video ID:</label>
      <input type="text" id="videoId" placeholder="Enter a video ID">
    </div>
    <button id="fetchVectorsBtn">Fetch Vector Chunks</button>
    <div id="vectorsResult"></div>
  </div>

  <script>
    // DOM Elements
    const apiUrlInput = document.getElementById('apiUrl');
    const updateApiUrlBtn = document.getElementById('updateApiUrl');
    const refreshAllDataBtn = document.getElementById('refreshAllData');
    
    // Latest sermon elements
    const latestSermonDateElement = document.getElementById('latestSermonDate');
    const daysSinceLatestElement = document.getElementById('daysSinceLatest');
    const latestEmbeddingDateElement = document.getElementById('latestEmbeddingDate');
    const latestSermonTitleElement = document.getElementById('latestSermonTitle');
    const latestSermonIdElement = document.getElementById('latestSermonId');
    const latestSermonFullDateElement = document.getElementById('latestSermonFullDate');
    const latestSermonStatusElement = document.getElementById('latestSermonStatus');
    const latestSermonLinkElement = document.getElementById('latestSermonLink');
    const latestSermonPreviewElement = document.getElementById('latestSermonPreview');
    const checkLatestBtn = document.getElementById('checkLatestBtn');
    
    // Stats elements
    const totalVectorsElement = document.getElementById('totalVectors');
    const totalSermonsElement = document.getElementById('totalSermons');
    const avgChunksElement = document.getElementById('avgChunks');
    const fetchStatsBtn = document.getElementById('fetchStatsBtn');
    const statsResult = document.getElementById('statsResult');
    
    // Sermons list elements
    const fetchSermonsBtn = document.getElementById('fetchSermonsBtn');
    const sermonsResult = document.getElementById('sermonsResult');
    const sermonsList = document.getElementById('sermonsList');
    const sortBySelect = document.getElementById('sortBy');
    const filterSermonsInput = document.getElementById('filterSermons');
    
    // Search elements
    const searchQuery = document.getElementById('searchQuery');
    const topK = document.getElementById('topK');
    const testSearchBtn = document.getElementById('testSearchBtn');
    const searchResult = document.getElementById('searchResult');
    
    // Vector explorer elements
    const videoId = document.getElementById('videoId');
    const fetchVectorsBtn = document.getElementById('fetchVectorsBtn');
    const vectorsResult = document.getElementById('vectorsResult');
    
    // Store API URL and data
    let apiUrl = apiUrlInput.value;
    let sermonsData = [];
    
    // Event Listeners
    updateApiUrlBtn.addEventListener('click', () => {
      apiUrl = apiUrlInput.value.trim();
      alert(`API URL updated to: ${apiUrl}`);
    });
    
    refreshAllDataBtn.addEventListener('click', async () => {
      await Promise.all([
        checkLatestSermon(),
        fetchDatabaseStats(),
        fetchSermonsList()
      ]);
    });
    
    checkLatestBtn.addEventListener('click', async () => {
      await checkLatestSermon();
    });
    
    fetchStatsBtn.addEventListener('click', async () => {
      await fetchDatabaseStats();
    });
    
    fetchSermonsBtn.addEventListener('click', async () => {
      await fetchSermonsList();
    });
    
    sortBySelect.addEventListener('change', () => {
      if (sermonsData.length > 0) {
        displaySermonsList(sermonsData);
      }
    });
    
    filterSermonsInput.addEventListener('input', () => {
      if (sermonsData.length > 0) {
        displaySermonsList(sermonsData);
      }
    });
    
    testSearchBtn.addEventListener('click', async () => {
      const query = searchQuery.value.trim();
      if (!query) {
        searchResult.innerHTML = '<p class="error">Please enter a search query.</p>';
        return;
      }
      
      const k = parseInt(topK.value) || 5;
      
      const data = {
        query: query,
        top_k: k,
        include_sources: true
      };
      
      await testEndpoint('/answer', 'POST', data, searchResult);
    });
    
    fetchVectorsBtn.addEventListener('click', async () => {
      const id = videoId.value.trim();
      if (!id) {
        vectorsResult.innerHTML = '<p class="error">Please enter a video ID.</p>';
        return;
      }
      
      await fetchVectorChunks(id);
    });
    
    // Check latest sermon status
    async function checkLatestSermon() {
      const latestCard = document.getElementById('latestSermonCard');
      latestCard.innerHTML = '<p>Checking latest sermon... <span class="loading"></span></p>';
      
      try {
        // Fetch sermons list if we don't already have it
        if (sermonsData.length === 0) {
          await fetchSermonsList();
        }
        
        if (sermonsData.length === 0) {
          latestCard.innerHTML = '<p class="error">No sermons found.</p>';
          return;
        }
        
        // Sort by date, newest first
        const sortedSermons = [...sermonsData].sort((a, b) => {
          // Extract dates in various formats
          const dateA = getDateFromSermon(a);
          const dateB = getDateFromSermon(b);
          
          if (dateA && dateB) {
            return dateB - dateA;
          } else {
            return 0;
          }
        });
        
        // Get the latest sermon
        const latestSermon = sortedSermons[0];
        
        if (!latestSermon) {
          latestCard.innerHTML = '<p class="error">Could not determine latest sermon.</p>';
          return;
        }
        
        // Update the card with the latest sermon info
        const sermonDate = getDateFromSermon(latestSermon);
        const formattedDate = sermonDate ? sermonDate.toLocaleDateString() : 'Unknown';
        const daysSince = sermonDate ? Math.floor((new Date() - sermonDate) / (1000 * 60 * 60 * 24)) : '-';
        
        // Get sermon with the latest embedding
        const sermonsWithEmbeddings = sortedSermons.filter(sermon => 
          sermon.vector_count && sermon.vector_count > 0
        );
        
        const latestEmbedding = sermonsWithEmbeddings.length > 0 ? sermonsWithEmbeddings[0] : null;
        const latestEmbeddingDate = latestEmbedding ? getDateFromSermon(latestEmbedding) : null;
        
        // Update stats cards
        latestSermonDateElement.textContent = formattedDate;
        daysSinceLatestElement.textContent = daysSince;
        latestEmbeddingDateElement.textContent = latestEmbeddingDate ? 
          latestEmbeddingDate.toLocaleDateString() : 'None';
        
        // Update card
        latestSermonTitleElement.textContent = latestSermon.title || 'Untitled Sermon';
        latestSermonIdElement.textContent = latestSermon.video_id || latestSermon.id || 'N/A';
        latestSermonFullDateElement.textContent = formattedDate;
        
        // Determine status
        let status = '';
        let statusClass = '';
        
        if (latestSermon.vector_count && latestSermon.vector_count > 0) {
          status = `✅ Embeddings complete (${latestSermon.vector_count} vectors)`;
          statusClass = 'success';
        } else if (latestSermon.processing_status === 'processed') {
          status = '⚠️ Transcript processed, awaiting embeddings';
          statusClass = 'warning';
        } else {
          status = '❌ Not processed';
          statusClass = 'error';
        }
        
        latestSermonStatusElement.textContent = status;
        latestSermonStatusElement.className = statusClass;
        
        // Create YouTube link
        const videoId = latestSermon.video_id || latestSermon.id;
        latestSermonLinkElement.href = `https://www.youtube.com/watch?v=${videoId}`;
        
        // Add YouTube preview
        latestSermonPreviewElement.innerHTML = `
          <iframe 
            width="100%" 
            height="315" 
            src="https://www.youtube.com/embed/${videoId}" 
            frameborder="0" 
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
            allowfullscreen>
          </iframe>
        `;
        
      } catch (error) {
        console.error('Error checking latest sermon:', error);
        latestCard.innerHTML = `
          <p class="error">Error checking latest sermon: ${error.message}</p>
        `;
      }
    }
    
    // Helper function to extract date from sermon object
    function getDateFromSermon(sermon) {
      // Try different date fields
      const dateFields = ['date', 'publish_date', 'upload_date', 'processing_date'];
      
      for (const field of dateFields) {
        if (sermon[field]) {
          try {
            // Handle different date formats
            let dateStr = sermon[field];
            
            // Format YYYYMMDD without separators
            if (/^\d{8}$/.test(dateStr)) {
              dateStr = `${dateStr.substring(0, 4)}-${dateStr.substring(4, 6)}-${dateStr.substring(6, 8)}`;
            }
            
            const date = new Date(dateStr);
            if (!isNaN(date.getTime())) {
              return date;
            }
          } catch (e) {
            console.warn(`Could not parse date field ${field}:`, e);
          }
        }
      }
      
      return null;
    }
    
    // Helper function to test an endpoint
    async function testEndpoint(endpoint, method, data, resultElement) {
      resultElement.innerHTML = '<p>Testing... <span class="loading"></span></p>';
      
      try {
        const url = `${apiUrl}${endpoint}`;
        console.log(`Making ${method} request to: ${url}`);
        
        const options = {
          method: method,
          headers: {
            'Accept': 'application/json'
          },
          mode: 'cors'
        };
        
        if (data && method !== 'GET') {
          options.headers['Content-Type'] = 'application/json';
          options.body = JSON.stringify(data);
        }
        
        const response = await fetch(url, options);
        const result = await response.json();
        
        console.log('Response status:', response.status);
        console.log('Response:', result);
        
        if (response.ok) {
          resultElement.innerHTML = `
            <p class="success">Success! Status: ${response.status}</p>
            <pre>${JSON.stringify(result, null, 2)}</pre>
          `;
          
          // If testing the sermons endpoint, populate the video ID field with the first sermon ID
          if (endpoint === '/sermons' && result.sermons && result.sermons.length > 0) {
            videoId.value = result.sermons[0].video_id;
            return result.sermons;
          }
          
          return result;
        } else {
          resultElement.innerHTML = `
            <p class="error">Error! Status: ${response.status}</p>
            <pre>${JSON.stringify(result, null, 2)}</pre>
          `;
          return null;
        }
      } catch (error) {
        console.error('Error:', error);
        resultElement.innerHTML = `
          <p class="error">Error: ${error.message}</p>
          <p>This could be due to:</p>
          <ul>
            <li>API server is down</li>
            <li>CORS issues</li>
            <li>Network connectivity problems</li>
            <li>Invalid endpoint</li>
          </ul>
          <p>Check the browser console for more details.</p>
        `;
        return null;
      }
    }
    
    // Fetch database stats
    async function fetchDatabaseStats() {
      statsResult.innerHTML = '<p>Fetching stats... <span class="loading"></span></p>';
      
      try {
        // This assumes you have a /stats endpoint, if not we'll use the sermons endpoint
        // and calculate stats from there
        const url = `${apiUrl}/stats`;
        const options = {
          method: 'GET',
          headers: { 'Accept': 'application/json' },
          mode: 'cors'
        };
        
        try {
          const response = await fetch(url, options);
          if (response.ok) {
            const result = await response.json();
            console.log('Stats:', result);
            
            // Update the stats display
            totalVectorsElement.textContent = result.total_vectors || '-';
            totalSermonsElement.textContent = result.total_sermons || '-';
            avgChunksElement.textContent = result.avg_chunks_per_sermon ? 
              result.avg_chunks_per_sermon.toFixed(1) : '-';
            
            statsResult.innerHTML = `
              <p class="success">Stats fetched successfully!</p>
              <pre>${JSON.stringify(result, null, 2)}</pre>
            `;
          } else {
            // If the /stats endpoint doesn't exist, fall back to /sermons
            await calculateStatsFromSermons();
          }
        } catch (error) {
          // If error, try the fallback method
          await calculateStatsFromSermons();
        }
      } catch (error) {
        console.error('Error fetching stats:', error);
        statsResult.innerHTML = `
          <p class="error">Error fetching stats: ${error.message}</p>
        `;
      }
    }
    
    // Calculate stats from sermons list
    async function calculateStatsFromSermons() {
      try {
        const sermonsUrl = `${apiUrl}/sermons`;
        const options = {
          method: 'GET',
          headers: { 'Accept': 'application/json' },
          mode: 'cors'
        };
        
        const response = await fetch(sermonsUrl, options);
        if (response.ok) {
          const result = await response.json();
          console.log('Sermons:', result);
          
          if (result.sermons && Array.isArray(result.sermons)) {
            // Save sermons data
            sermonsData = result.sermons;
            
            // Calculate stats
            const totalSermons = result.sermons.length;
            
            // If vector_count is available in the response
            let totalVectors = 0;
            let hasVectorCounts = false;
            
            result.sermons.forEach(sermon => {
              if (sermon.vector_count !== undefined) {
                totalVectors += sermon.vector_count;
                hasVectorCounts = true;
              }
            });
            
            // Update the stats display
            totalSermonsElement.textContent = totalSermons;
            
            if (hasVectorCounts) {
              totalVectorsElement.textContent = totalVectors;
              avgChunksElement.textContent = (totalVectors / totalSermons).toFixed(1);
            } else {
              // If vector_count is not available, we'll need to make an educated guess
              // or make additional API calls to fetch vector counts
              totalVectorsElement.textContent = "N/A";
              avgChunksElement.textContent = "N/A";
            }
            
            statsResult.innerHTML = `
              <p class="success">Stats calculated from sermons list!</p>
              <p>Note: Vector counts may be estimated if not directly provided by the API.</p>
            `;
            
            // Also update the latest sermon info
            checkLatestSermon();
          } else {
            statsResult.innerHTML = `
              <p class="error">Could not calculate stats: Invalid sermon data format.</p>
            `;
          }
        } else {
          statsResult.innerHTML = `
            <p class="error">Failed to fetch sermons for stat calculation.</p>
          `;
        }
      } catch (error) {
        console.error('Error calculating stats:', error);
        statsResult.innerHTML = `
          <p class="error">Error calculating stats: ${error.message}</p>
        `;
      }
    }
    
    // Fetch sermons list
    async function fetchSermonsList() {
      sermonsResult.innerHTML = '<p>Fetching sermons... <span class="loading"></span></p>';
      
      try {
        const sermons = await testEndpoint('/sermons', 'GET', null, sermonsResult);
        if (sermons && sermons.sermons && Array.isArray(sermons.sermons)) {
          sermonsData = sermons.sermons;
          displaySermonsList(sermonsData);
        }
      } catch (error) {
        console.error('Error fetching sermons:', error);
      }
    }
    
    // Display sermons list
    function displaySermonsList(sermons) {
      // Filter sermons if filter input has text
      const filterText = filterSermonsInput.value.toLowerCase();
      let filteredSermons = sermons;
      
      if (filterText) {
        filteredSermons = sermons.filter(sermon => {
          const title = (sermon.title || '').toLowerCase();
          const id = (sermon.video_id || sermon.id || '').toLowerCase();
          return title.includes(filterText) || id.includes(filterText);
        });
      }
      
      // Sort sermons based on selected option
      const sortBy = sortBySelect.value;
      
      if (sortBy === 'date') {
        filteredSermons.sort((a, b) => {
          // Sort by date if available, otherwise by title
          const dateA = getDateFromSermon(a);
          const dateB = getDateFromSermon(b);
          
          if (dateA && dateB) {
            return dateB - dateA;
          } else {
            return a.title.localeCompare(b.title);
          }
        });
      } else if (sortBy === 'chunks') {
        filteredSermons.sort((a, b) => {
          // Sort by vector_count if available
          const countA = a.vector_count || 0;
          const countB = b.vector_count || 0;
          return countB - countA;
        });
      } else if (sortBy === 'title') {
        filteredSermons.sort((a, b) => a.title.localeCompare(b.title));
      }
      
      // Generate HTML
      let html = '';
      
      if (filteredSermons.length === 0) {
        html = '<p>No sermons found matching your filter.</p>';
      } else {
        // Find the most recent date to highlight
        let mostRecentDate = null;
        filteredSermons.forEach(sermon => {
          const date = getDateFromSermon(sermon);
          if (date && (!mostRecentDate || date > mostRecentDate)) {
            mostRecentDate = date;
          }
        });
        
        filteredSermons.forEach(sermon => {
          const date = getDateFromSermon(sermon);
          const formattedDate = date ? date.toLocaleDateString() : 'No date';
          const vectorCount = sermon.vector_count !== undefined ? sermon.vector_count : 'N/A';
          const isLatest = date && mostRecentDate && date.getTime() === mostRecentDate.getTime();
          
          // Determine status
          let status = '';
          let statusClass = '';
          
          if (sermon.vector_count && sermon.vector_count > 0) {
            status = `✅ Embeddings complete (${sermon.vector_count} vectors)`;
            statusClass = 'success';
          } else if (sermon.processing_status === 'processed') {
            status = '⚠️ Transcript processed, awaiting embeddings';
            statusClass = 'warning';
          } else {
            status = '❌ Not processed';
            statusClass = 'error';
          }
          
          html += `
            <div class="card ${isLatest ? 'latest-sermon' : ''}">
              <h3>${sermon.title || 'Untitled Sermon'}</h3>
              <p><strong>ID:</strong> ${sermon.video_id || sermon.id || 'N/A'}</p>
              <p><strong>Date:</strong> ${formattedDate}</p>
              <p><strong>Status:</strong> <span class="${statusClass}">${status}</span></p>
              <p><strong>YouTube:</strong> <a href="https://www.youtube.com/watch?v=${sermon.video_id || sermon.id}" target="_blank">View on YouTube</a></p>
              <button class="view-vectors-btn" data-id="${sermon.video_id || sermon.id}">View Vector Chunks</button>
            </div>
          `;
        });
      }
      
      sermonsList.innerHTML = html;
      
      // Add event listeners to the "View Vector Chunks" buttons
      document.querySelectorAll('.view-vectors-btn').forEach(button => {
        button.addEventListener('click', () => {
          const id = button.getAttribute('data-id');
          videoId.value = id;
          fetchVectorsBtn.click();
        });
      });
    }
    
    // Fetch vector chunks for a sermon
    async function fetchVectorChunks(id) {
      vectorsResult.innerHTML = '<p>Fetching vector chunks... <span class="loading"></span></p>';
      
      try {
        // Assuming you have an endpoint that returns vector chunks for a sermon
        // If not, you'll need to adapt this to your API
        const url = `${apiUrl}/vectors/${id}`;
        const options = {
          method: 'GET',
          headers: { 'Accept': 'application/json' },
          mode: 'cors'
        };
        
        try {
          const response = await fetch(url, options);
          const result = await response.json();
          
          if (response.ok) {
            console.log('Vector chunks:', result);
            
            vectorsResult.innerHTML = `
              <p class="success">Vector chunks fetched successfully!</p>
              <pre>${JSON.stringify(result, null, 2)}</pre>
            `;
          } else {
            // Fallback to sermon details if vector-specific endpoint doesn't exist
            await fetchSermonDetails(id);
          }
        } catch (error) {
          // If error, try the fallback method
          await fetchSermonDetails(id);
        }
      } catch (error) {
        console.error('Error fetching vector chunks:', error);
        vectorsResult.innerHTML = `
          <p class="error">Error fetching vector chunks: ${error.message}</p>
        `;
      }
    }
    
    // Fetch sermon details
    async function fetchSermonDetails(id) {
      try {
        const url = `${apiUrl}/sermons/${id}`;
        const options = {
          method: 'GET',
          headers: { 'Accept': 'application/json' },
          mode: 'cors'
        };
        
        const response = await fetch(url, options);
        const result = await response.json();
        
        if (response.ok) {
          console.log('Sermon details:', result);
          
          vectorsResult.innerHTML = `
            <p class="success">Sermon details fetched successfully!</p>
            <p>Note: Vector chunks detail may not be available directly. This shows the sermon metadata instead.</p>
            <pre>${JSON.stringify(result, null, 2)}</pre>
          `;
        } else {
          vectorsResult.innerHTML = `
            <p class="error">Failed to fetch sermon details. Status: ${response.status}</p>
            <pre>${JSON.stringify(result, null, 2)}</pre>
          `;
        }
      } catch (error) {
        console.error('Error fetching sermon details:', error);
        vectorsResult.innerHTML = `
          <p class="error">Error fetching sermon details: ${error.message}</p>
        `;
      }
    }
    
    // Initialize by fetching stats when the page loads
    window.addEventListener('DOMContentLoaded', () => {
      fetchDatabaseStats();
      checkLatestSermon();
    });
  </script>
</body>
</html>